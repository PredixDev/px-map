{"version":3,"sources":["px-map-behavior-marker-group.es6.js"],"names":["namespace","window","PxMapBehavior","MarkerGroupImpl","properties","name","type","String","notify","data","Object","observer","colorsByType","value","getComputedStyleValue","iconFns","cluster","undefined","marker","clusterConfig","addInst","parent","LayerImpl","call","spiderifyFn","_handleClusterSpiderify","bind","unspiderifyFn","_handleClusterUnspiderify","bindEvents","removeInst","createInst","options","L","markerClusterGroup","features","length","_syncDataWithMarkers","updateInst","lastOptions","nextOptions","elementInst","fire","getInstOptions","defaultOptions","showCoverageOnHover","maxClusterRadius","spiderifyOnMaxZoom","removeOutsideVisibleBounds","animate","polygonOptions","stroke","color","fillColor","fillOpacity","assign","iconCreateFunction","_createClusterIcon","markers","getAllChildMarkers","count","types","_indexClusterMarkersByType","colors","containerSize","_getClusterIconSize","pathSize","_getStyleValueAsNum","borderSize","countByType","PxMap","ClusterIcon","styleValName","__styleVals","computedVal","indexOf","valWithoutSuffix","replace","valAsNum","Math","floor","reduce","featureProperties","newFeatures","clusterInst","featuresSet","_features","Set","markersMap","_markers","WeakMap","_diffNewFeatures","featuresToAdd","featuresToUpdate","featuresToRemove","nextFeaturesSet","nextMarkersMap","feature","cachedMarker","markersToOperate","size","get","_createMarker","push","set","addLayers","_updateMarker","refreshClusters","_removeMarker","delete","removeLayers","clear","lastFeatureSet","markerMap","i","len","valid","known","featureHash","id","geometry","coordinates","Array","has","add","hash","JSON","stringify","markerData","lat","lng","iconSettings","_extractMarkerIconSettings","icon","_createMarkerIcon","setIcon","featSettings","featSettingsKeys","keys","featKeyCamelized","substring","match","charAt","toUpperCase","klassName","base","_strToKlassName","str","evt","localEvt","Polymer","dom","node","_icon","style","visibility","MarkerGroup","Layer"],"mappings":"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","file":"px-map-behavior-marker-group.js","sourcesContent":["(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  const namespace = (window.PxMapBehavior = window.PxMapBehavior || {});\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.MarkerGroup\n   */\n  const MarkerGroupImpl = {\n    properties: {\n      /**\n       * A human-readable name for this layer group. If the map has a layer\n       * control panel, the user will click this name to show, hide, or\n       * manipulate this layer.\n       *\n       * @type {String}\n       */\n      name: {\n        type: String,\n        notify: true\n      },\n\n      /**\n       * A GeoJSON FeatureCollection object containing an array of Features with\n       * point data that will be represented as a marker.\n       *\n       * @type {Object}\n       */\n      data: {\n        type: Object,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * An object mapping categories of icons to their respective colors. Each\n       * key should be a string representing the name of an `icon-type` to\n       * a valid CSS color value (e.g. hex color, `rgb()` color). Set the\n       * `icon-type` as a sub-property of `properties.marker-icon` for each marker\n       * feature in the FeatureCollection you pass into the `data` attribute.\n       *\n       * By default, the available types are:\n       * - \"unknown\" : \"--px-map-marker-group-unknown-color\" (default: gray)\n       * - \"info\" : \"--px-map-marker-group-info-color\" (default: blue)\n       * - \"warning\" : \"--px-map-marker-group-info-color\" (default: yellow)\n       * - \"important\" : \"--px-map-marker-group-info-color\" (default: red)\n       *\n       * Example #1 - FeatureCollection for `data`:\n       *\n       * ```\n       * {\n       *   \"type\" : \"FeatureCollection\",\n       *   \"features\" : [\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"001\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"info\"\n       *         }\n       *       }\n       *     },\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"002\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"warning\"\n       *         }\n       *       }\n       *     }\n       *   ]\n       * }\n       * ```\n       *\n       * Example #1 - `colorsByType` object\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"warning\" : \"red\"\n       * }\n       * ```\n       *\n       * The default `colorsByType` mapping is:\n       */\n      colorsByType: {\n        type: Object,\n        value: function(){\n          return {\n            \"unknown\" : this.getComputedStyleValue('--px-map-marker-group-unknown-color'),\n            \"info\" : this.getComputedStyleValue('--px-map-marker-group-info-color'),\n            \"warning\" : this.getComputedStyleValue('--px-map-marker-group-warning-color'),\n            \"important\" : this.getComputedStyleValue('--px-map-marker-group-important-color')\n          }\n        }\n      },\n\n      iconFns: {\n        type: Object,\n        value: function(){\n          return {\n            cluster: undefined,\n            marker: undefined\n          }\n        }\n      },\n\n      clusterConfig: {\n        type: Object\n      }\n    },\n\n    addInst(parent) {\n      PxMapBehavior.LayerImpl.addInst.call(this, parent);\n\n      // Bind custom events for this cluster. Events will be unbound automatically.\n      const spiderifyFn = this._handleClusterSpiderify.bind(this);\n      const unspiderifyFn = this._handleClusterUnspiderify.bind(this);\n      this.bindEvents({\n        'spiderfied' : spiderifyFn,\n        'unspiderfied' : unspiderifyFn\n      });\n    },\n\n    removeInst(parent) {\n      PxMapBehavior.LayerImpl.removeInst.call(this, parent);\n    },\n\n    createInst(options={}) {\n      const cluster = L.markerClusterGroup(options);\n\n      if (options.data && options.data.features && options.data.features.length) {\n        this._syncDataWithMarkers(options.data.features, cluster);\n      }\n\n      return cluster;\n    },\n\n    updateInst(lastOptions, nextOptions) {\n      if (nextOptions.data && nextOptions.data.features && nextOptions.data.features.length) {\n        this._syncDataWithMarkers(nextOptions.data.features, this.elementInst);\n        this.fire('px-map-marker-group-add');\n      }\n    },\n\n    getInstOptions() {\n      // Set the default cluster options\n      const defaultOptions = {\n        showCoverageOnHover: true,\n        maxClusterRadius: 150,\n        spiderifyOnMaxZoom: true,\n        removeOutsideVisibleBounds: true,\n        animate: true,\n        polygonOptions: {\n          stroke: true,\n          color: this.getComputedStyleValue('--px-map-marker-group-cluster-polygon-stroke-color'),\n          fillColor: this.getComputedStyleValue('--px-map-marker-group-cluster-polygon-fill-color'),\n          fillOpacity: 0.4\n        }\n      };\n      // Overwrite with any developer-provided cluster options in `clusterConfig`\n      const options = Object.assign(defaultOptions, (this.clusterConfig || {}));\n      // Assign the `data` and `iconCreateFunction` options. These cannot be\n      // configured through the `clusterConfig` attribture\n      options.data = this.data;\n      options.iconCreateFunction = this._createClusterIcon.bind(this);\n      // Return the options composed together\n      return options;\n    },\n\n    _createClusterIcon(cluster) {\n      // If the developer supplies a `iconFns.cluster` function, pass the options\n      // to that function and return the result.\n      if (this.iconFns.cluster) {\n        return this.iconFns.cluster.call(this, cluster);\n      }\n\n      // Otherwise, build the marker ourselves\n      const markers = cluster.getAllChildMarkers();\n      const count = markers.length;\n\n      // Count markers and group by type\n      const types = this._indexClusterMarkersByType(markers);\n      // Get the colors for each type\n      const colors = this.colorsByType;\n\n      // Get the container size for this count\n      const containerSize = this._getClusterIconSize(count);\n      // Get the path (chart stroke width) and border width for this chart\n      const pathSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-path-size') || 10;\n      const borderSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-border-size') || 0;\n\n      // Set up the options to send into ClusterIcon\n      const options = {\n        count: count,\n        countByType: types,\n        colorsByType: colors,\n        containerSize: containerSize,\n        pathSize: pathSize,\n        borderSize: borderSize\n      };\n\n      return new PxMap.ClusterIcon(options);\n    },\n\n    _getStyleValueAsNum(styleValName) {\n      // Try to get from the \"cache\"\n      this.__styleVals = (this.__styleVals || {});\n      if (this.__styleVals[styleValName]) return this.__styleVals[styleValName];\n\n      const computedVal = this.getComputedStyleValue(styleValName);\n\n      if (computedVal && computedVal.indexOf('px') !== -1) {\n        const valWithoutSuffix = computedVal.replace('px','');\n        const valAsNum = Math.floor(valWithoutSuffix);\n        this.__styleVals[styleValName] = valAsNum;\n        return valAsNum;\n      } else {\n        return undefined;\n      }\n    },\n\n    _getClusterIconSize(count) {\n      // for count 1-9, size is small\n      if (count < 10) {\n        return 60;\n      }\n      // for count 10-39, size is medium\n      if ((count >= 10) && (count < 40)) {\n        return 75;\n      }\n      // for count 40+, size is large\n      if (count > 40) {\n        return 90;\n      }\n    },\n\n    /**\n     * Takes a group of marker instances and returns an object with keys of the\n     * marker types in the group and values with the number of markers in\n     * each group.\n     *\n     * @param {Array} markers - Array of marker instances\n     * @return {Object}\n     */\n    _indexClusterMarkersByType(markers) {\n      return markers.reduce((types, marker) => {\n        if (marker.featureProperties && marker.featureProperties['marker-icon'] && marker.featureProperties['marker-icon']['icon-type']) {\n          types[marker.featureProperties['marker-icon']['icon-type']] = (types[marker.featureProperties['marker-icon']['icon-type']] || 0) + 1;\n        }\n        return types;\n      }, {});\n    },\n\n    _syncDataWithMarkers(newFeatures, clusterInst) {\n      if (!newFeatures.length) return;\n\n      const featuresSet = this._features = (this._features || new Set());\n      const markersMap = this._markers = (this._markers || new WeakMap());\n\n      const {featuresToAdd, featuresToUpdate, featuresToRemove, nextFeaturesSet, nextMarkersMap} = this._diffNewFeatures(newFeatures, featuresSet, markersMap);\n\n      let feature, cachedMarker, markersToOperate;\n\n      if (featuresToAdd.size) {\n        markersToOperate = [];\n        for (feature of featuresToAdd) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._createMarker(feature);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.addLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToUpdate.size) {\n        markersToOperate = [];\n        for (feature of featuresToUpdate) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._updateMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.refreshClusters(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToRemove.size) {\n        markersToOperate = [];\n        for (feature of featuresToRemove) {\n          cachedMarker = nextMarkersMap.get(feature);\n          this._removeMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.delete(feature);\n        }\n        clusterInst.removeLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      this._features = nextFeaturesSet;\n      this._markers = nextMarkersMap;\n      featuresSet.clear()\n\n      featuresToAdd.clear();\n      featuresToUpdate.clear();\n      featuresToRemove.clear();\n    },\n\n    _diffNewFeatures(newFeatures, lastFeatureSet, markerMap) {\n      // Keep track of our new feature set, which will replace `featureSet`\n      const nextFeaturesSet = new Set();\n\n      // Keep track of markers to add\n      const featuresToAdd = new Set();\n      const featuresToUpdate = new Set();\n\n      // Placeholders for our loop\n      let i, len, valid, known, cachedMarker, featureHash;\n\n      // Loop over features to add unknown features to the cluster or update known features if necessary\n      for (i=0, len=newFeatures.length; i<len; i++) {\n        // If these tests aren't met, the feature is invalid and can't be drawn as a marker\n        // Any invalid markers won't be visited and will be removed\n        valid = ((newFeatures[i].id) && (newFeatures[i].geometry && newFeatures[i].geometry.type === 'Point') && (newFeatures[i].geometry.coordinates instanceof Array && newFeatures[i].geometry.coordinates.length === 2));\n        if (!valid) continue;\n\n        // Determine if this feature is already represented in the cluster\n        known = lastFeatureSet.has(newFeatures[i]);\n\n        // This is a valid feature we don't know, create a marker for this feature and add it.\n        if (!known) {\n          // Mark this as a marker to add\n          featuresToAdd.add(newFeatures[i]);\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n          // Build a new cached marker object with a hash of the feature\n          cachedMarker = { marker: null, hash: JSON.stringify(newFeatures[i]) };\n          markerMap.set(newFeatures[i], cachedMarker);\n          // Skip to next loop iteration\n          continue;\n        }\n\n        // We know this feature and have a marker for it. Ensure the marker is up-to-date.\n        if (known) {\n          cachedMarker = markerMap.get(newFeatures[i]);\n          featureHash = JSON.stringify(newFeatures[i]);\n          // If there's a difference, mark this marker as one to update\n          if (cachedMarker.hash !== featureHash) {\n            featuresToUpdate.add(newFeatures[i]);\n            // Update the cached marker object with the new hash of the feature\n            cachedMarker.hash = featureHash;\n            markerMap.set(newFeatures[i], cachedMarker);\n          }\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n        }\n      }\n\n      // Any markers remaining in the last feature set need to be remove\n      const featuresToRemove = lastFeatureSet.size ? lastFeatureSet : new Set();\n\n      // Clear all references in the last feature set to ensure values can\n      // be garbage collected\n      lastFeatureSet.clear();\n      lastFeatureSet = null;\n\n      return {\n        featuresToAdd: featuresToAdd,\n        featuresToUpdate: featuresToUpdate,\n        featuresToRemove: featuresToRemove,\n        nextFeaturesSet: nextFeaturesSet,\n        nextMarkersMap: markerMap\n      };\n    },\n\n    _removeMarker(markerData, clusterInst){\n      // debugger;\n    },\n\n    _createMarker(feature, clusterInst) {\n      // Extract geometry (GeoJSON coordinate pairs are Lat/Lng, we need Lng/Lat,\n      // so we have to reverse)\n      const [lat, lng] = feature.geometry.coordinates;\n      // Create a marker\n      const marker = L.marker([lng, lat]);\n\n      // If any icon settings were passed with the feature, fetch them to pass\n      // to the icon constructor\n      const iconSettings = (feature.properties['marker-icon']) ? this._extractMarkerIconSettings(feature.properties['marker-icon']) : {};\n      const icon = this._createMarkerIcon(iconSettings);\n      marker.setIcon(icon);\n\n      // Attach the properties to the marker instance to read later\n      marker.featureProperties = feature.properties;\n\n      return marker;\n    },\n\n    _extractMarkerIconSettings(featSettings) {\n      const featSettingsKeys = Object.keys(featSettings);\n      if (!featSettingsKeys.length) return undefined;\n\n      const iconSettings = {};\n      let i, len, featKeyCamelized;\n\n      for (i=0, len=featSettingsKeys.length; i<len; i++) {\n        if (featSettingsKeys[i].substring(0,5) !== \"icon-\") continue;\n        featKeyCamelized = featSettingsKeys[i].substring(5).replace(/(\\-[a-z])/g, (match) => match.charAt(1).toUpperCase());\n        iconSettings[featKeyCamelized] = featSettings[featSettingsKeys[i]];\n      }\n\n      return iconSettings;\n    },\n\n    _createMarkerIcon(options) {\n      // If the developer supplies a `iconFns.marker` function, pass the options\n      // to that function and return the result.\n      if (this.iconFns.marker) {\n        return this.iconFns.marker.call(this, options);\n      }\n      // Otherwise, attempt to convert the feature's 'icon-base' to a klass name\n      // and call the constructor for that klass\n      const klassName = options.base ? this._strToKlassName(options.base) : 'StaticIcon';\n      return new PxMap[klassName](options);\n    },\n\n    _strToKlassName(str) {\n      return str.charAt(0).toUpperCase() + str.substring(1).replace(/(\\-[a-z])/g, (match) => match.charAt(1).toUpperCase());\n    },\n\n    /**\n     * When the cluster is spiderified, set its visibility to hidden to ensure\n     * it is not kept around as an opaque background to the markers.\n     */\n    _handleClusterSpiderify(evt) {\n      const localEvt = Polymer.dom(evt);\n      const node = localEvt.node;\n      if (!node || !node.cluster || !node.cluster._icon) return;\n\n      node.cluster._icon.style.visibility = 'hidden';\n    },\n\n    /**\n     * When the cluster is unspiderified, set its visibility to visible to ensure\n     * it is shown again on the map.\n     */\n    _handleClusterUnspiderify(evt) {\n      const localEvt = Polymer.dom(evt);\n      const node = localEvt.node;\n      if (!node || !node.cluster || !node.cluster._icon) return;\n\n      node.cluster._icon.style.visibility = 'visible';\n    }\n  };\n  /* Bind MarkerGroup behavior */\n  namespace.MarkerGroup = [\n    namespace.Layer,\n    MarkerGroupImpl\n  ];\n\n})();\n"]}